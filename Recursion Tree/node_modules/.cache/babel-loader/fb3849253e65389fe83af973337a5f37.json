{"ast":null,"code":"// draw tree class functions start :/\nexport class Tree {\n  constructor() {\n    let node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let label = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    this.id = 0;\n    this.node = node;\n    this.label = label;\n    this.width = node.length;\n    this.children = children;\n  }\n\n}\nexport class DrawTree {\n  constructor(tree) {\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let number = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    this.left = () => {\n      if (this.thread !== undefined) return this.thread;\n      if (this.children.length !== 0) return this.children[0];\n      return undefined;\n      return this.thread || this.children.length && this.children[0];\n    };\n\n    this.right = () => {\n      if (this.thread) return this.thread;\n      if (this.children.length) return this.children[this.children.length - 1];\n      return undefined;\n      return this.thread || this.children.length && this.children[-1];\n    };\n\n    this.lbrother = () => {\n      let n = undefined;\n\n      if (this.parent) {\n        // for(let node in this.parent.children)\n        for (let i = 0; i < this.parent.children.length; i++) {\n          let node = this.parent.children[i];\n\n          if (node === this) {\n            return n;\n          } else {\n            n = node;\n          }\n        }\n      }\n\n      return n;\n    };\n\n    this.get_lmost_sibling = () => {\n      if (!this._lmost_sibling && this.parent && this !== this.parent.children[0]) {\n        this._lmost_sibling = this.parent.children[0];\n      }\n\n      return this._lmost_sibling;\n    };\n\n    this.x = -1;\n    this.y = depth;\n    this.tree = tree;\n    this.children = [];\n\n    for (let i = 0; i < tree.children.length; i++) {\n      let newTree = new DrawTree(tree.children[i], this, depth + 1, i + 1);\n      this.children.push(newTree);\n    }\n\n    this.parent = parent;\n    this.thread = undefined;\n    this.mod = 0;\n    this.ancestor = this;\n    this.change = 0;\n    this.shift = 0;\n    this._lmost_sibling = undefined;\n    this.number = number; // this.lmost_sibling = this.get_lmost_sibling();\n  }\n\n}\nexport function buchheim(tree) {\n  let dt = firstwalk(new DrawTree(tree));\n  let min = second_walk(dt);\n\n  if (min < 0) {\n    third_walk(dt, -min);\n  }\n\n  return dt;\n}\n\nfunction third_walk(tree, n) {\n  tree.x += n; //for (let c in tree.children)\n\n  for (let i = 0; i < tree.children; i++) {\n    let c = tree.children[i];\n    third_walk(c, n);\n  }\n}\n\nfunction firstwalk(v) {\n  let distance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n  //console.log('hue hue hue',v);\n  if (v.children.length === 0) {\n    if (v.get_lmost_sibling()) {\n      v.x = v.lbrother().x + distance;\n    } else {\n      v.x = 0.;\n    }\n  } else {\n    let default_ancestor = v.children[0]; //for (let w in v.children)\n\n    for (let i = 0; i < v.children.length; i++) {\n      let w = v.children[i];\n      firstwalk(w);\n      default_ancestor = apportion(w, default_ancestor, distance);\n    } // console.log(\"finished v =\", v.tree, \"children\");\n\n\n    execute_shifts(v);\n    let midpoint = (v.children[0].x + v.children[v.children.length - 1].x) / 2;\n    let ell = v.children[0];\n    let arr = v.children[-1];\n    let w = v.lbrother();\n\n    if (w) {\n      v.x = w.x + distance;\n      v.mod = v.x - midpoint;\n    } else {\n      v.x = midpoint;\n    }\n  }\n\n  return v;\n}\n\nfunction apportion(v, default_ancestor, distance) {\n  let w = v.lbrother();\n\n  if (w !== undefined) {\n    // inbuchheimnotation:\n    //i == inner;o == outer;r == right;l == left;r = +;l = -\n    let vir, vor, vil, vol, sir, sor, sol, sil;\n    vir = vor = v;\n    vil = w;\n    vol = v.get_lmost_sibling();\n    sir = sor = v.mod;\n    sil = vil.mod;\n    sol = vol.mod;\n\n    while (vil.right() && vir.left()) {\n      vil = vil.right();\n      vir = vir.left();\n      vol = vol.left();\n      vor = vor.right();\n      vor.ancestor = v;\n      let shift = vil.x + sil - (vir.x + sir) + distance;\n\n      if (shift > 0) {\n        move_subtree(ancestor(vil, v, default_ancestor), v, shift);\n        sir = sir + shift;\n        sor = sor + shift;\n      }\n\n      sil += vil.mod;\n      sir += vir.mod;\n      sol += vol.mod;\n      sor += vor.mod;\n    }\n\n    if (vil.right() && !vor.right()) {\n      vor.thread = vil.right();\n      vor.mod += sil - sor;\n    } else {\n      if (vir.left() && !vol.left()) {\n        vol.thread = vir.left();\n        vol.mod += sir - sol;\n      }\n\n      default_ancestor = v;\n    }\n  }\n\n  return default_ancestor;\n}\n\nfunction move_subtree(wl, wr, shift) {\n  let subtrees = wr.number - wl.number; // console.log(wl.tree, \"is conflicted with\", wr.tree, 'moving', subtrees, 'shift', shift);\n  // print wl, wr, wr.number, wl.number, shift, subtrees, shift / subtrees\n\n  wr.change -= shift / subtrees;\n  wr.shift += shift;\n  wl.change += shift / subtrees;\n  wr.x += shift;\n  wr.mod += shift;\n}\n\nfunction execute_shifts(v) {\n  let shift, change;\n  shift = change = 0; // for (let w in v.children[:: - 1])\n\n  for (let i = v.children.length - 1; i >= 0; i--) {\n    let w = v.children[i]; //console.log(\"shift:\", w.tree.node, shift, w.change);\n\n    w.x += shift;\n    w.mod += shift;\n    change += w.change;\n    shift += w.shift + change;\n  }\n}\n\nfunction ancestor(vil, v, default_ancestor) {\n  if (vil.ancestor in v.parent.children) {\n    return vil.ancestor;\n  } else return default_ancestor;\n}\n\nfunction second_walk(v) {\n  let m = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let min = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n  v.x += m;\n  v.y = depth;\n  if (min === undefined || v.x < min) min = v.x; // for (let w in v.children)\n\n  for (let i = 0; i < v.children.length; i++) {\n    let w = v.children[i];\n    min = second_walk(w, m + v.mod, depth + 1, min);\n  }\n\n  return min;\n}\n\nfunction dfs(tree) {\n  if (tree.tree.node === 'B') return;\n  console.log(tree.tree.node, tree.x, tree.y);\n\n  for (let i = 0; i < tree.children.length; i++) dfs(tree.children[i]);\n}\n/*\nlet blank = new Tree('B',[]);\nlet ll = new Tree(\"ll\",[]);\nlet lr = new Tree(\"lr\",[]);\nlet rr = new Tree(\"rr\",[]);\nlet rl = new Tree(\"rl\",[]);\nlet l = new Tree(\"l\",[ll,lr]);\nlet r = new Tree(\"r\",[rl,rr]);\nlet root = new Tree(\"root\",[l,r] );\n\nlet tree = buchheim(root);\nconsole.log(\"==================================================================\");\ndfs(tree);\n*/","map":{"version":3,"names":["Tree","constructor","node","children","label","id","width","length","DrawTree","tree","parent","undefined","depth","number","left","thread","right","lbrother","n","i","get_lmost_sibling","_lmost_sibling","x","y","newTree","push","mod","ancestor","change","shift","buchheim","dt","firstwalk","min","second_walk","third_walk","c","v","distance","default_ancestor","w","apportion","execute_shifts","midpoint","ell","arr","vir","vor","vil","vol","sir","sor","sol","sil","move_subtree","wl","wr","subtrees","m","dfs","console","log"],"sources":["D:/Major/Project/Recursion Tree/src/Graph/Tree.js"],"sourcesContent":["// draw tree class functions start :/\n\n\nexport class Tree{\n    constructor(node=0,children=[],label=\"\") {\n        this.id = 0;\n        this.node = node;\n        this.label = label;\n        this.width = node.length;\n        this.children = children;\n    }\n}\n\nexport class DrawTree{\n    constructor(tree,parent=undefined,depth=0,number=1) {\n        this.x =-1;\n        this.y = depth;\n        this.tree = tree;\n        this.children = [];\n        for( let i=0;i<tree.children.length;i++ ){\n            let newTree = new DrawTree(tree.children[i],this,depth+1,i+1);\n            this.children.push(newTree);\n        }\n        this.parent = parent;\n        this.thread = undefined;\n        this.mod = 0;\n        this.ancestor = this;\n        this.change = 0;\n        this.shift = 0;\n        this._lmost_sibling = undefined;\n        this.number = number;\n        // this.lmost_sibling = this.get_lmost_sibling();\n    }\n\n    left = ()=>{\n        if( this.thread!==undefined ) return this.thread;\n        if( this.children.length!==0 ) return this.children[0];\n        return undefined;\n        return this.thread || this.children.length && this.children[0];\n    }\n    right = ()=>{\n        if( this.thread ) return this.thread;\n        if( this.children.length ) return this.children[this.children.length-1];\n        return undefined;\n        return this.thread || this.children.length && this.children[-1];\n    }\n    lbrother = ()=>{\n        let n = undefined;\n        if( this.parent ){\n            // for(let node in this.parent.children)\n            for(let i=0;i<this.parent.children.length;i++)\n            {\n                let node = this.parent.children[i];\n                if( node === this ){\n                    return n;\n                }else{\n                    n = node;\n                }\n            }\n        }\n        return n;\n    }\n    get_lmost_sibling = ()=>{\n        if( !this._lmost_sibling && this.parent && this!==this.parent.children[0] ){\n            this._lmost_sibling = this.parent.children[0];\n        }\n        return this._lmost_sibling;\n    }\n\n\n}\n\n\n\n\nexport function buchheim(tree) {\n    let dt = firstwalk(new DrawTree(tree))\n    let min = second_walk(dt)\n    if (min < 0) {\n        third_walk(dt, -min);\n    }\n    return dt\n}\n\nfunction third_walk(tree, n) {\n    tree.x += n;\n    //for (let c in tree.children)\n    for(let i=0;i<tree.children;i++)\n    {\n        let c = tree.children[i];\n        third_walk(c, n);\n    }\n}\n\nfunction firstwalk(v, distance = 1) {\n    //console.log('hue hue hue',v);\n    if (v.children.length === 0) {\n        if (v.get_lmost_sibling()) {\n            v.x = v.lbrother().x + distance;\n        } else {\n            v.x = 0.;\n        }\n    } else {\n        let default_ancestor = v.children[0];\n        //for (let w in v.children)\n        for(let i=0;i<v.children.length;i++) {\n            let w = v.children[i];\n            firstwalk(w);\n            default_ancestor = apportion(w, default_ancestor, distance);\n        }\n        // console.log(\"finished v =\", v.tree, \"children\");\n        execute_shifts(v);\n\n        let midpoint = (v.children[0].x + v.children[v.children.length-1].x) / 2;\n\n        let ell = v.children[0];\n        let arr = v.children[-1];\n        let w = v.lbrother();\n        if (w) {\n            v.x = w.x + distance;\n            v.mod = v.x - midpoint;\n        } else {\n            v.x = midpoint;\n        }\n    }\n    return v;\n}\n\n\nfunction apportion(v, default_ancestor, distance) {\n\n    let w = v.lbrother();\n    if (w !== undefined) {\n        // inbuchheimnotation:\n        //i == inner;o == outer;r == right;l == left;r = +;l = -\n        let vir, vor, vil, vol, sir, sor, sol, sil;\n        vir = vor = v;\n        vil = w;\n        vol = v.get_lmost_sibling();\n        sir = sor = v.mod;\n        sil = vil.mod;\n        sol = vol.mod;\n        while (vil.right() && vir.left()) {\n            vil = vil.right();\n            vir = vir.left();\n            vol = vol.left();\n            vor = vor.right();\n            vor.ancestor = v;\n            let shift = (vil.x + sil) - (vir.x + sir) + distance;\n            if (shift > 0) {\n                move_subtree(ancestor(vil, v, default_ancestor), v, shift);\n                sir = sir + shift;\n                sor = sor + shift;\n            }\n            sil += vil.mod;\n            sir += vir.mod;\n            sol += vol.mod;\n            sor += vor.mod;\n        }\n        if (vil.right() && !vor.right()) {\n            vor.thread = vil.right();\n            vor.mod += sil - sor;\n        } else {\n            if (vir.left() && !vol.left()) {\n                vol.thread = vir.left();\n                vol.mod += sir - sol;\n            }\n            default_ancestor = v\n        }\n    }\n    return default_ancestor\n}\n\nfunction move_subtree(wl, wr, shift) {\n    let subtrees = wr.number - wl.number;\n    // console.log(wl.tree, \"is conflicted with\", wr.tree, 'moving', subtrees, 'shift', shift);\n    // print wl, wr, wr.number, wl.number, shift, subtrees, shift / subtrees\n    wr.change -= shift / subtrees;\n    wr.shift += shift;\n    wl.change += shift / subtrees;\n    wr.x += shift;\n    wr.mod += shift;\n}\n\nfunction execute_shifts(v) {\n    let shift, change;\n    shift = change = 0;\n    // for (let w in v.children[:: - 1])\n    for(let i=v.children.length-1;i>=0;i--){\n        let w = v.children[i];\n        //console.log(\"shift:\", w.tree.node, shift, w.change);\n        w.x += shift;\n        w.mod += shift;\n        change += w.change;\n        shift += w.shift + change;\n    }\n}\n\nfunction ancestor(vil, v, default_ancestor) {\n\n    if (vil.ancestor in v.parent.children){\n\n        return vil.ancestor;\n    }\n    else\n        return default_ancestor;\n}\n\nfunction second_walk(v, m = 0, depth = 0, min = undefined) {\n    v.x += m;\n    v.y = depth;\n\n    if (min === undefined || v.x < min)\n        min = v.x;\n\n    // for (let w in v.children)\n    for(let i=0;i<v.children.length;i++){\n        let w = v.children[i];\n        min = second_walk(w, m + v.mod, depth + 1, min);\n    }\n    return min;\n}\n\nfunction dfs(tree){\n    if( tree.tree.node === 'B' ) return;\n    console.log( tree.tree.node, tree.x,tree.y );\n    for(let i=0;i<tree.children.length;i++)\n        dfs(tree.children[i]);\n}\n/*\nlet blank = new Tree('B',[]);\nlet ll = new Tree(\"ll\",[]);\nlet lr = new Tree(\"lr\",[]);\nlet rr = new Tree(\"rr\",[]);\nlet rl = new Tree(\"rl\",[]);\nlet l = new Tree(\"l\",[ll,lr]);\nlet r = new Tree(\"r\",[rl,rr]);\nlet root = new Tree(\"root\",[l,r] );\n\nlet tree = buchheim(root);\nconsole.log(\"==================================================================\");\ndfs(tree);\n*/\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}