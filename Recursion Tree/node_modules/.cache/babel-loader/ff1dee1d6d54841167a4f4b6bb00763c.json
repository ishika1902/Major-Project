{"ast":null,"code":"import { Tree, buchheim } from './Tree';\nexport function getTree(n) {\n  let algo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (algo === 0) return buchheim(fib(n));else if (algo === 1) return buchheim(NcR(n, r));else if (algo === 2) return buchheim(derangement(n));else if (algo === 3) return buchheim(bigmod(n, r));\n}\n\nfunction fib(n) {\n  let tree = new Tree(n, [], n + \"\");\n  if (n < 2) return tree;\n  tree.children.push(fib(n - 1));\n  tree.children.push(fib(n - 2));\n  tree.node = tree.children[0].node + tree.children[1].node;\n  return tree;\n}\n\nfunction sib(n) {\n  let tree = new Tree(n, []);\n  if (n < 3) return tree;\n  tree.children.push(sib(n - 2));\n  tree.children.push(sib(n - 3));\n  tree.node = tree.children[0].node + tree.children[1].node;\n  return tree;\n}\n\nfunction NcR(n, r) {\n  if (r > n) return new Tree(-1, [], \"(\" + n + \",\" + r + \")\");\n  if (n === r) return new Tree(1, [], \"(\" + n + \",\" + r + \")\");\n  if (r === 0) return new Tree(1, [], \"(\" + n + \",\" + r + \")\");\n  ; // nCr(n, r) = nCr(n - 1, r - 1) + nCr(n - 1, r)\n\n  let tree = new Tree(0, [], \"(\" + n + \",\" + r + \")\");\n  tree.children.push(NcR(n - 1, r - 1));\n  tree.children.push(NcR(n - 1, r));\n  tree.node = tree.children[0].node + tree.children[1].node;\n  return tree;\n}\n\n_c = NcR;\n\nfunction derangement(n) {\n  if (n == 0) return new Tree(1, [], n + \"\");\n  if (n == 1) return new Tree(0, [], n + \"\");\n  let tree = new Tree(0, [], n + \"\");\n  tree.children.push(derangement(n - 1));\n  tree.children.push(derangement(n - 2));\n  tree.node = (n - 1) * (tree.children[0].node + tree.children[1].node);\n  return tree;\n} // function bigmod(n,r){\n//     if( r === 0 ) return new Tree(1,[],\"(\"+n+\",\"+r+\")\");\n//     if( r === 1 ) return new Tree(n,[],\"(\"+n+\",\"+r+\")\");\n//     let tree = new Tree(1,[],\"(\"+n+\",\"+r+\")\");\n//     if( r%2 === 1 ){\n//         tree.children.push( bigmod(n,(r-1)/2 ) );\n//         tree.children.push( bigmod(n,(r-1)/2) );\n//         tree.children.push( bigmod(n,1) );\n//     }else{\n//         tree.children.push( bigmod(n,r/2 ) );\n//         tree.children.push( bigmod(n,r/2) );\n//     }\n//     for(let i=0;i<tree.children.length;i++){\n//         tree.node *= tree.children[i].node;\n//     }\n//     return tree;\n// }\n\n\nvar _c;\n\n$RefreshReg$(_c, \"NcR\");","map":{"version":3,"names":["Tree","buchheim","getTree","n","algo","r","fib","NcR","derangement","bigmod","tree","children","push","node","sib"],"sources":["D:/Major/Recursion Tree/src/Graph/fib.jsx"],"sourcesContent":["import {Tree,buchheim} from './Tree';\nexport function getTree(n,algo=0,r=0){\n    if(algo === 0)\n        return buchheim( fib(n) );\n    else if( algo === 1 )\n        return buchheim(NcR(n,r));\n    else if( algo === 2 )\n        return buchheim(derangement(n));\n    else if( algo === 3 )\n        return buchheim(bigmod(n,r));\n}\n\nfunction fib(n){\n    let tree = new Tree(n,[],n+\"\");\n    if( n <2 ) return tree;\n    tree.children.push( fib(n-1) );\n    tree.children.push( fib(n-2) );\n    tree.node = tree.children[0].node+tree.children[1].node;\n    return tree;\n}\n\nfunction sib(n){\n    let tree = new Tree(n,[]);\n    if( n <3 ) return tree;\n    tree.children.push( sib(n-2) );\n    tree.children.push( sib(n-3) );\n    tree.node = tree.children[0].node+tree.children[1].node;\n    return tree;\n}\n\nfunction NcR(n,r){\n    if (r > n)\n        return new Tree(-1,[],\"(\"+n+\",\"+r+\")\");\n\n    if (n === r)\n        return new Tree(1,[],\"(\"+n+\",\"+r+\")\");\n\n    if (r === 0)\n        return new Tree(1,[],\"(\"+n+\",\"+r+\")\");;\n\n    // nCr(n, r) = nCr(n - 1, r - 1) + nCr(n - 1, r)\n    let tree = new Tree(0,[],\"(\"+n+\",\"+r+\")\");\n    tree.children.push( NcR(n-1,r-1) );\n    tree.children.push( NcR(n-1,r) );\n    tree.node = tree.children[0].node+tree.children[1].node;\n    return tree;\n}\n\nfunction derangement(n){\n    if( n == 0 ) return new Tree(1,[],n+\"\");\n    if( n == 1 ) return new Tree(0,[],n+\"\");\n    let tree = new Tree(0,[],n+\"\");\n    tree.children.push( derangement(n-1) );\n    tree.children.push( derangement(n-2) );\n    tree.node = (n-1)*(tree.children[0].node+tree.children[1].node);\n    return tree;\n}\n\n// function bigmod(n,r){\n//     if( r === 0 ) return new Tree(1,[],\"(\"+n+\",\"+r+\")\");\n//     if( r === 1 ) return new Tree(n,[],\"(\"+n+\",\"+r+\")\");\n//     let tree = new Tree(1,[],\"(\"+n+\",\"+r+\")\");\n//     if( r%2 === 1 ){\n//         tree.children.push( bigmod(n,(r-1)/2 ) );\n//         tree.children.push( bigmod(n,(r-1)/2) );\n//         tree.children.push( bigmod(n,1) );\n//     }else{\n//         tree.children.push( bigmod(n,r/2 ) );\n//         tree.children.push( bigmod(n,r/2) );\n//     }\n//     for(let i=0;i<tree.children.length;i++){\n//         tree.node *= tree.children[i].node;\n//     }\n//     return tree;\n// }\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}